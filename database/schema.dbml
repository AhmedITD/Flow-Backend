// Flow Database Schema
// Generated for dbdiagram.io

Project Flow {
  database_type: 'PostgreSQL'
  Note: 'Flow - AI-powered Call Center Management System'
}

// Enums
Enum service_type {
  call_center [note: 'Call Center service with ticket management']
  hr [note: 'HR service with employee support tools']
}

// Users and Authentication
Table users {
  id bigint [pk, increment]
  name varchar [not null]
  phone_number varchar(20) [unique, not null]
  phone_verified_at timestamp [null]
  password varchar [not null]
  remember_token varchar [null]
  created_at timestamp
  updated_at timestamp
  
  Note: 'User accounts for agents and system users. Phone number authentication with OTP verification via OTPIQ'
}

Table phone_verification_codes {
  id bigint [pk, increment]
  phone_number varchar(20) [not null]
  code varchar(6) [not null, note: '6-digit OTP code for registration']
  expires_at timestamp [not null]
  verified_at timestamp [null]
  is_used boolean [default: false]
  ip_address varchar(45) [null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    phone_number
    (phone_number, code, is_used)
    (phone_number, expires_at)
  }
  
  Note: 'OTP codes for phone number verification during registration via OTPIQ SMS/WhatsApp service. User must request code via /api/auth/send-verification (phone must NOT be registered), then use code during registration.'
}

Table sessions {
  id varchar [pk]
  user_id bigint [null, ref: > users.id]
  ip_address varchar(45) [null]
  user_agent text [null]
  payload longtext [not null]
  last_activity integer [not null]
  
  Note: 'User session data'
}

// Tickets Management
Table tickets {
  ticket_id uuid [pk]
  tenant_id uuid [not null]
  channel enum [default: 'chat', note: 'voice, chat']
  status enum [default: 'open', note: 'open, pending, resolved, closed']
  priority enum [default: 'medium', note: 'low, medium, high, urgent']
  category enum [default: 'general', note: 'billing, technical, shipping, account, general, other']
  subject varchar [not null]
  summary text [not null]
  created_by_type varchar [default: 'system', note: 'agent or system']
  created_by_id varchar [null, note: 'agent_id or system']
  assigned_to uuid [null, ref: > users.id]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    tenant_id
    assigned_to
    (tenant_id, status)
    (tenant_id, priority)
    (status, priority)
    created_at
  }
  
  Note: 'Support tickets for customer service'
}

// Subscription & Usage Tracking
Table plans {
  id uuid [pk]
  name varchar [not null]
  slug varchar [unique, not null]
  description text [null]
  price decimal(10,2) [not null, note: 'Subscription fee. Can be 0 for pure pay-as-you-go plans']
  currency varchar(3) [default: 'IQD']
  billing_period enum [default: 'monthly', note: 'monthly, yearly, one_time']
  trial_days integer [default: 0]
  is_active boolean [default: true]
  features json [null, note: 'Array of plan features']
  limits json [null, note: 'Service limits and pricing. Format: {"service_type": {"tokens": int, "price_per_token": decimal, "price_per_1k_tokens": decimal, "pay_as_you_go": boolean}}']
  created_at timestamp
  updated_at timestamp
  
  Note: 'Subscription plans with features, limits, and token pricing. Supports both subscription-based and pay-as-you-go pricing models. For pay-as-you-go: price=0, limits contain price_per_token or price_per_1k_tokens, pay_as_you_go=true'
}

Table subscriptions {
  id uuid [pk]
  user_id bigint [not null, ref: > users.id]
  plan_id uuid [not null, ref: > plans.id]
  status enum [default: 'trial', note: 'active, cancelled, expired, trial, past_due']
  starts_at timestamp [not null]
  ends_at timestamp [null]
  trial_ends_at timestamp [null]
  cancelled_at timestamp [null]
  auto_renew boolean [default: true]
  metadata json [null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (user_id, status)
    ends_at
  }
  
  Note: 'User subscriptions to plans'
}

Table subscription_services {
  id uuid [pk]
  subscription_id uuid [not null, ref: > subscriptions.id]
  service_type service_type [not null, note: 'Enum: call_center, hr']
  allocated_tokens integer [default: 0, note: 'Token limit for this subscription service. For pay-as-you-go plans, this is typically 0']
  tokens_used integer [default: 0, note: 'Total tokens consumed. Used to calculate usage-based payments']
  reset_at timestamp [not null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (subscription_id, service_type) [unique]
    reset_at
    service_type
  }
  
  Note: 'Service allocations per subscription with token limits and usage tracking. Token usage is tracked for both subscription limits and pay-as-you-go billing'
}

Table usage_records {
  id uuid [pk]
  subscription_id uuid [not null, ref: > subscriptions.id]
  service_type service_type [not null, note: 'Enum: call_center, hr']
  tokens_used integer [not null, note: 'Tokens consumed in this request (prompt_tokens + completion_tokens from OpenAI)']
  action_type varchar [null]
  resource_id varchar [null]
  metadata json [null]
  recorded_at timestamp [not null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (subscription_id, service_type, recorded_at)
    recorded_at
    service_type
  }
  
  Note: 'Append-only log of usage. tokens_used = tokens consumed per request, calculated from OpenAI API responses'
}

Table billing_cycles {
  id uuid [pk]
  subscription_id uuid [not null, ref: > subscriptions.id]
  payment_id uuid [null, ref: > payments.id]
  period_start date [not null]
  period_end date [not null]
  status enum [default: 'pending', note: 'pending, paid, failed, refunded']
  amount decimal(10,2) [not null]
  currency varchar(3) [default: 'IQD']
  paid_at timestamp [null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (subscription_id, status)
  }
  
  Note: 'Billing cycle tracking for recurring subscriptions'
}

// Payments
Table payments {
  id uuid [pk]
  user_id bigint [not null, ref: > users.id]
  subscription_id uuid [null, ref: > subscriptions.id]
  transaction_id varchar [unique, null]
  qicard_payment_id varchar [null]
  amount decimal(10,2) [not null, note: 'Payment amount. Can be subscription fee or usage-based charges']
  currency varchar(3) [default: 'IQD']
  status enum [default: 'pending', note: 'pending, processing, completed, failed, cancelled']
  description text [null, note: 'Payment description. Usage payments: "Usage-based payment for token consumption"']
  payment_method varchar [null]
  metadata json [null, note: 'Additional payment data. For usage payments: {"type": "usage", "services": [{"service_type": "call_center", "tokens_used": int, "cost": decimal}]}']
  qicard_response json [null]
  paid_at timestamp [null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (user_id, status)
    subscription_id
    transaction_id
    qicard_payment_id
  }
  
  Note: 'Payment transactions linked to subscriptions. Includes both subscription fees and usage-based (pay-as-you-go) payments. Usage payments are created via /api/subscriptions/{id}/usage-payment endpoint'
}

// Chat/Conversation System
// Note: Conversations and messages are not persisted. The chat service is stateless.

// API Key Management
Table api_keys {
  id uuid [pk]
  user_id bigint [not null, ref: > users.id]
  subscription_id uuid [null, ref: > subscriptions.id]
  name varchar [not null]
  key_hash varchar [unique, not null]
  key_prefix varchar(20) [not null]
  status enum [default: 'active', note: 'active, revoked, expired']
  last_used_at timestamp [null]
  expires_at timestamp [null]
  revoked_at timestamp [null]
  metadata json [null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (user_id, status)
    key_prefix
    last_used_at
  }
  
  Note: 'API keys for programmatic access'
}

Table api_key_services {
  id uuid [pk]
  api_key_id uuid [not null, ref: > api_keys.id]
  service_type service_type [not null, note: 'Enum: call_center, hr']
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (api_key_id, service_type) [unique]
    service_type
  }
  
  Note: 'Many-to-many relationship between API keys and services. Each API key can have access to multiple services (call_center, hr).'
}

Table api_key_usage {
  id uuid [pk]
  api_key_id uuid [not null, ref: > api_keys.id]
  endpoint varchar [not null]
  method varchar(10) [not null]
  status_code integer [not null]
  response_time_ms integer [null]
  ip_address varchar(45) [null]
  user_agent text [null]
  metadata json [null]
  used_at timestamp [not null]
  created_at timestamp
  updated_at timestamp
  
  indexes {
    (api_key_id, used_at)
    used_at
  }
  
  Note: 'API key usage tracking for analytics'
}
